import { TokenMetadataResponse } from 'alchemy-sdk';
import { getRandomEVMAddress } from '../../../utils/testing';
import { AlchemyService, AlchemyServiceError } from '../alchemy.service';

describe('AlchemyService', () => {
  describe('getERC20TokenList()', () => {
    it('should return a list of ERC20 token balances when a valid address is provided', async () => {
      const address = getRandomEVMAddress();
      const expectedTokenList = [
        { tokenBalance: '1', contractAddress: getRandomEVMAddress() },
        { tokenBalance: '2', contractAddress: getRandomEVMAddress() },
      ];
      const alchemyService = new AlchemyService();
      // @ts-expect-error because we are mocking a private property
      alchemyService.alchemyClient.core.getTokenBalances = jest.fn().mockResolvedValue(expectedTokenList);

      const result = await alchemyService.getERC20TokenList(address);

      expect(result).toEqual(expectedTokenList);
      // @ts-expect-error because we are mocking a private property
      expect(alchemyService.alchemyClient.core.getTokenBalances).toHaveBeenCalledWith(address);
    });

    it('should throw an AlchemyServiceError with the correct error message when the Alchemy client fails to fetch the ERC20 token balances', async () => {
      // Arrange
      const address = getRandomEVMAddress();
      const alchemyService = new AlchemyService();
      // @ts-expect-error because we are mocking a private property
      alchemyService.alchemyClient.core.getTokenBalances = jest
        .fn()
        .mockRejectedValue(new Error('Failed to fetch token balances'));

      // Act and Assert
      await expect(alchemyService.getERC20TokenList(address)).rejects.toThrow(
        new AlchemyServiceError(
          `Error fetching ERC20 token list for address ${address}: Error: Failed to fetch token balances`
        )
      );
      // @ts-expect-error because we are mocking a private property
      expect(alchemyService.alchemyClient.core.getTokenBalances).toHaveBeenCalledWith(address);
    });
  });

  // Generated by CodiumAI

  describe('getERC20TokenMetadata()', () => {
    it('should return token metadata when a valid contract address is provided', async () => {
      const contractAddress = getRandomEVMAddress();
      const metadataResponse = {
        name: 'Token Name',
        symbol: 'TKN',
        decimals: 18,
      };

      const alchemyService = new AlchemyService();
      // @ts-expect-error because we are mocking a private property
      alchemyService.alchemyClient.core.getTokenMetadata = jest.fn().mockResolvedValue(metadataResponse);

      const result = await alchemyService.getERC20TokenMetadata(contractAddress);

      expect(result).toEqual(metadataResponse);
      // @ts-expect-error because we are mocking a private property
      expect(alchemyService.alchemyClient.core.getTokenMetadata).toHaveBeenCalledWith(contractAddress);
    });

    it('should return cached token metadata if it exists', async () => {
      const contractAddress = getRandomEVMAddress();
      const metadataResponse = {
        name: 'Token Name',
        symbol: 'TKN',
        decimals: 18,
      };

      // Mock the cache
      AlchemyService.tokenMetadataCache.has = jest.fn().mockReturnValue(true);
      AlchemyService.tokenMetadataCache.get = jest.fn().mockReturnValue(metadataResponse);

      const alchemyService = new AlchemyService();
      const result = await alchemyService.getERC20TokenMetadata(contractAddress);

      expect(result).toEqual(metadataResponse);
      expect(AlchemyService.tokenMetadataCache.has).toHaveBeenCalledWith(contractAddress);
      expect(AlchemyService.tokenMetadataCache.get).toHaveBeenCalledWith(contractAddress);
    });

    it('should throw AlchemyServiceError if fetching token metadata fails', async () => {
      const contractAddress = getRandomEVMAddress();
      const error = new Error('Failed to fetch token metadata');

      AlchemyService.tokenMetadataCache.has = jest.fn().mockReturnValue(false);

      const alchemyService = new AlchemyService();
      // @ts-expect-error because we are mocking a private property
      alchemyService.alchemyClient.core.getTokenMetadata = jest.fn().mockRejectedValue(error);

      await expect(alchemyService.getERC20TokenMetadata(contractAddress)).rejects.toThrow(
        new AlchemyServiceError(`Error fetching token metadata for contract address ${contractAddress}: ${error}`)
      );
      expect(AlchemyService.tokenMetadataCache.has).toHaveBeenCalledWith(contractAddress);
      // @ts-expect-error because we are mocking a private property
      expect(alchemyService.alchemyClient.core.getTokenMetadata).toHaveBeenCalledWith(contractAddress);
    });
  });

  describe('getERC20TokenListViewModel()', () => {
    it('should return a list of ERC20 token balances with metadata when a valid address is provided', async () => {
      const address = getRandomEVMAddress();
      const tokenList = [
        { tokenBalance: '100000000', contractAddress: getRandomEVMAddress() },
        { tokenBalance: '200000000', contractAddress: getRandomEVMAddress() },
      ];
      const metadata = {
        name: 'USD Coin',
        symbol: 'USDC',
        decimals: 6,
      };

      const alchemyService = new AlchemyService();
      alchemyService.getERC20TokenList = jest.fn().mockResolvedValue({ tokenBalances: tokenList });
      alchemyService.getERC20TokenMetadata = jest.fn().mockResolvedValue(metadata);

      const result = await alchemyService.getERC20TokenListViewModel(address);

      expect(result).toEqual([
        { name: metadata.name, symbol: metadata.symbol, balance: 100 },
        { name: metadata.name, symbol: metadata.symbol, balance: 200 },
      ]);
      expect(alchemyService.getERC20TokenList).toHaveBeenCalledWith(address);
      expect(alchemyService.getERC20TokenMetadata).toHaveBeenCalledTimes(2);
    });

    it('should filter out tokens with missing metadata', async () => {
      const address = getRandomEVMAddress();
      const tokenList = [
        { tokenBalance: '100000000', contractAddress: getRandomEVMAddress() },
        { tokenBalance: '200000000', contractAddress: getRandomEVMAddress() },
      ];
      const metadata = {
        name: 'USD Coin',
        symbol: 'USDC',
        decimals: null,
        logo: null,
      };

      const alchemyService = new AlchemyService();
      alchemyService.getERC20TokenList = jest.fn().mockResolvedValue({ tokenBalances: tokenList });
      alchemyService.getERC20TokenMetadata = jest.fn((contractAddress: string): Promise<TokenMetadataResponse> => {
        if (contractAddress === tokenList[0].contractAddress || contractAddress === tokenList[1].contractAddress) {
          return Promise.resolve(metadata);
        }
        return Promise.resolve({ name: null, symbol: '', decimals: null, logo: null });
      });

      const result = await alchemyService.getERC20TokenListViewModel(address);

      expect(result).toEqual([]);
      expect(alchemyService.getERC20TokenList).toHaveBeenCalledWith(address);
      expect(alchemyService.getERC20TokenMetadata).toHaveBeenCalledTimes(2);
    });

    it('should filter out tokens with zero balances', async () => {
      const address = getRandomEVMAddress();
      const tokenList = [
        { tokenBalance: '0', contractAddress: getRandomEVMAddress() },
        { tokenBalance: '200000000', contractAddress: getRandomEVMAddress() },
      ];
      const metadata = {
        name: 'USD Coin',
        symbol: 'USDC',
        decimals: 6,
      };

      const alchemyService = new AlchemyService();
      alchemyService.getERC20TokenList = jest.fn().mockResolvedValue({ tokenBalances: tokenList });
      alchemyService.getERC20TokenMetadata = jest.fn().mockResolvedValue(metadata);

      const result = await alchemyService.getERC20TokenListViewModel(address);

      expect(result).toEqual([{ name: metadata.name, symbol: metadata.symbol, balance: 200 }]);
      expect(alchemyService.getERC20TokenList).toHaveBeenCalledWith(address);
      expect(alchemyService.getERC20TokenMetadata).toHaveBeenCalledTimes(1);
    });
  });
});
